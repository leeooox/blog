<!DOCTYPE html>
<html lang="zh_cn">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="https://blog.sipi.tech/theme/css/elegant.prod.9e9d5ce754.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://blog.sipi.tech/theme/css/custom.css" media="screen">

        <link rel="dns-prefetch" href="//fonts.loli.net">
        <link rel="preconnect" href="https://gstatic.loli.net/" crossorigin>

        <meta name="author" content="Aaron Lee" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="verilog, digital, FPGA, verilog, " />

<meta property="og:title" content="读书笔记 - Clifford E. Cummings关于verilog delay行为模型的论文 "/>
<meta property="og:url" content="https://blog.sipi.tech/verilog_note_about_delay.html" />
<meta property="og:description" content="读论文笔记，Clifford E. Cummings关于verilog delay行为模型的论文" />
<meta property="og:site_name" content="SIPI Tech" />
<meta property="og:article:author" content="Aaron Lee" />
<meta property="og:article:published_time" content="2021-07-31T16:35:54.943500+08:00" />
<meta property="og:article:modified_time" content="2021-07-31T16:35:54.943500+08:00" />
<meta name="twitter:title" content="读书笔记 - Clifford E. Cummings关于verilog delay行为模型的论文 ">
<meta name="twitter:description" content="读论文笔记，Clifford E. Cummings关于verilog delay行为模型的论文">

        <title>读书笔记 - Clifford E. Cummings关于verilog delay行为模型的论文  · SIPI Tech
</title>
        <link href="https://blog.sipi.tech/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="SIPI Tech - Full Atom Feed" />



	<script src="https://cdn.bootcdn.net/ajax/libs/wavedrom/2.8.1/skins/default.js" type="text/javascript"></script>
	<script src="https://cdn.bootcdn.net/ajax/libs/wavedrom/2.8.1/wavedrom.min.js" type="text/javascript"></script>
    </head>
    <body onload="WaveDrom.ProcessAll()">
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="https://blog.sipi.tech/"><span class=site-name>SIPI Tech</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       https://blog.sipi.tech
                                    >Home</a>
                                </li>
                                <li ><a href="https://blog.sipi.tech/categories.html">Categories</a></li>
                                <li ><a href="https://blog.sipi.tech/tags.html">Tags</a></li>
                                <li ><a href="https://blog.sipi.tech/archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="https://blog.sipi.tech/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="https://blog.sipi.tech/verilog_note_about_delay.html">
                读书笔记 - Clifford E. Cummings关于verilog&nbsp;delay行为模型的论文
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <p>拜读大神Clifford Cummings的论文 <a class="reference external" href="http://www.sunburst-design.com/papers/CummingsHDLCON1999_BehavioralDelays_Rev1_1.pdf">&lt;&lt;Correct Methods For Adding Delays To Verilog Behavioral Models&gt;&gt;</a>
这篇论文详细的说明了nonblocking和blocking，Continuous assignment，以及LHS，RHS各种组合情况下，那些delay是由缺陷的，那些是正确的。并且针对模型和test bench各做了说明。&nbsp;看完之后，对delay会了解的比较清楚，有时间的建议读一读原文，就8页内容。</p>
<div class="section" id="inertial-and-transport-delay">
<h2>1. Inertial and transport&nbsp;delay建模</h2>
<p>verilog是硬件描述语言，用途可以作为模型和test bench。对于模型来说，描述出来的模型无法由硬件实现，那么没有实际意义。
对于test&nbsp;bench则不需要硬件可以实现，它的目的只是为了测试模型。所以此论文也是分情况说明白了这些问题。</p>
<dl class="docutils">
<dt>Inertial&nbsp;delay</dt>
<dd>Inertial delay models only propagate signals to an output after the input signals have remained unchanged (been stable) for a time period equal to or greater than the propagation delay of the model.
If the time between two input changes is shorter than a procedural assignment delay, a continuous assignment delay, or gate delay, a previously scheduled but unrealized output event is replaced with a newly scheduled output&nbsp;event.</dd>
<dt>Transport&nbsp;delay</dt>
<dd>Transport delay models propagate all signals to an output after any input signals change. Scheduled output value changes are queued for transport delay&nbsp;models.</dd>
<dt>Reject <span class="amp">&amp;</span> Error&nbsp;delay</dt>
<dd>Reject <span class="amp">&amp;</span> Error delay models propagate all signals that are greater than the error setting, propagate unknown values for signals that fall between the reject <span class="amp">&amp;</span> error settings, and do not propagate signals that fall below the reject&nbsp;setting.</dd>
</dl>
</div>
<div class="section" id="blocking-assignment-delay-models">
<h2>2. Blocking assignment delay&nbsp;models</h2>
<div class="section" id="lhs-blocking-delays">
<h3>2.1. <span class="caps">LHS</span> blocking&nbsp;delays</h3>
<p>left-hand-side (<span class="caps">LHS</span>) or right hand-side (<span class="caps">RHS</span>)&nbsp;如下图所示，是2种不同的方式，对于的行为也不一样。</p>
<div class="highlight"><pre><span></span><span class="c1">// Procedural blocking assignment - no delay</span>
<span class="k">always</span> <span class="p">@(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>

<span class="c1">// Procedural blocking assignment - LHS delay</span>
<span class="k">always</span> <span class="p">@(</span><span class="n">a</span><span class="p">)</span>
    <span class="p">#</span><span class="mh">5</span> <span class="n">y</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>

<span class="c1">// Procedural blocking assignment - RHS delay</span>
<span class="k">always</span> <span class="p">@(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">#</span><span class="mh">5</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>
</pre></div>
<p>下面的adder_t1的代码的例子，输出应该在输入改变之后的12ns之后做出更新。
假如输入a在15ns时刻变化，那么如果a,b,ci在接下来的9ns无论任何时候发生变化，输出都只会在9ns结束的时候变化。&nbsp;那么这个模型只允许ci输入延时3ns到sum和carry输出，而不是12ns。</p>
<div class="highlight"><pre><span></span><span class="no">`timescale</span> <span class="mh">1</span><span class="n">ns</span> <span class="o">/</span> <span class="mh">100</span><span class="n">ps</span>


<span class="k">module</span> <span class="n">adder_t1</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span>
    <span class="p">#</span><span class="mh">12</span> <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
<p>这个是仿真的结果，仿真工具用的是免费的 <a class="reference external" href="http://iverilog.icarus.com/">Icarus Verilog</a>&nbsp;,用gtkwave看波形。</p>
<div class="figure">
<img alt="Waveforms for adder_t1.v Example" src="images/tb_adder_t1.png" />
<p class="caption">adder_t1仿真波形</p>
</div>
<script type="WaveDrom">
{signal: [
  {name:'a',      wave: '2..............3...4.5........', data: '0 A 2 F' },
  {name:'b',      wave: '2................3............', data: '0 3' },
  {name:'ci',     wave: '2.......................3.....', data: '0 1' },
  {},
  {name:'sum',    wave: 'x...........3..............4..', data: '0 3' },
  {name:'co',     wave: 'x...........3..............4..', data: '0 1' }
],
 head:{
   text:'adder_t1时序图(wavedrom小试牛刀)',
   tick:0,
 },
}
</script><p>同样，给任何时序逻辑LHS延时的组合逻辑都是有缺陷的。</p>
<p>下面的代码中adder_t7a，把延时放在了第1个blocking&nbsp;assign上，第2个assign没有延时，它和adder_t1存在同样的缺陷。</p>
<p>adder_t7b, 第1个blocking assign没有延时, 第2个blocking assign上有延时。这里存在的问题是输入变动，临时的值会保持12ns才能传输到输出，而且12ns任何变化都不能体现到输出，&nbsp;这就说老的错误的值会保持，直到更多的输入值发生变化。这些adder模型不能给任何已知的硬件建模(不存在这样行为的硬件)。</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t7a</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span> <span class="k">begin</span>
    <span class="p">#</span><span class="mh">12</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
      <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">end</span>
<span class="k">endmodule</span>

<span class="k">module</span> <span class="n">adder_t7b</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
    <span class="p">#</span><span class="mh">12</span> <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
<p><strong>建模的准则:</strong> 不要把delay放在blocking&nbsp;assignment的LHS来建模组合逻辑，这是一个糟糕的编码方式。</p>
<p><strong>Test bench准则:</strong> 把delay放在test bench blocking&nbsp;assignment的LHS是合理的，这个是用来做激励的时间顺序间隔的。</p>
</div>
<div class="section" id="rhs-blocking-delays">
<h3>2.2. <span class="caps">RHS</span> blocking&nbsp;delays</h3>
<p>blocking&nbsp;assignment组合逻辑，把delay放在RHS同样也是有缺陷。</p>
<p>如下面的代码，输出值应该再输入变化之后的12ns更新。如果a在15ns的时候变化，RHS的输入值会被采样到，并保持到12ns之后，&nbsp;但是12ns之类a,b,ci的变化则不会影响。也就说老的错误的值也会保留直到更多的输入变化。</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t6</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span>
    <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="p">#</span><span class="mh">12</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
<p>下面的adder_t11a和adder_t11b也有和adder_t6同样的问题。&nbsp;没有任何已知的硬件和上述RHS描述的模型一样。</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t11a</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>

  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span> <span class="k">begin</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">#</span><span class="mh">12</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
    <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">end</span>
<span class="k">endmodule</span>


<span class="k">module</span> <span class="n">adder_t11b</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>

  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span> <span class="k">begin</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
    <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="p">#</span><span class="mh">12</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
<p><strong>建模的准则:</strong> 不要把delay放在blocking&nbsp;assignment的LHS来建模组合逻辑，这是一个糟糕的编码方式。</p>
<p><strong>Test bench准则:</strong> 把delay放在test bench blocking&nbsp;assignment的RHS非常容易引起误解，尽量避免这种方式。</p>
</div>
</div>
<div class="section" id="nonblocking-assignment-delay-models">
<h2>3. Nonblocking assignment delay&nbsp;models</h2>
<div class="highlight"><pre><span></span><span class="c1">// Procedural nonblocking assignment - no delay</span>
<span class="k">always</span> <span class="p">@(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">&lt;=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>

<span class="c1">// Procedural nonblocking assignment - LHS delay</span>
<span class="k">always</span> <span class="p">@(</span><span class="n">a</span><span class="p">)</span>
  <span class="p">#</span><span class="mh">5</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>

<span class="c1">// Procedural nonblocking assignment - RHS delay</span>
<span class="k">always</span> <span class="p">@(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">&lt;=</span> <span class="p">#</span><span class="mh">5</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>
</pre></div>
<div class="section" id="lhs-nonblocking-delays">
<h3>3.1. <span class="caps">LHS</span> nonblocking&nbsp;delays</h3>
<p>nonblocking assignments放在LHS也是有缺陷。下面adder_t2的例子存在和adder_t1一样的问题。如果在时间15ns处输入a改变，&nbsp;在接下来的9ns内如果a,b,ci有变化，输出是根据最后的a,b,ci的值来更新。这样的模型ci的变化传输到输出sum和carry只要3ns。</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t2</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>

  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span>
    <span class="p">#</span><span class="mh">12</span> <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
<p><strong>建模的准则:</strong> 不要把delay放在nonblocking&nbsp;assignment的LHS来建模组合逻辑，这是一个糟糕的编码方式。</p>
<p><strong>Test bench准则:</strong> nonblocking assignment比blocking assignment仿真效率低；因此，不推荐把delay放在nonblocking&nbsp;assignment的LHS</p>
</div>
<div class="section" id="rhs-nonblocking-delays">
<h3>3.2. <span class="caps">RHS</span> nonblocking&nbsp;delays</h3>
<p>nonblocking assignments的RHS delay可以非常精确的描述组合逻辑的传输延时(transport&nbsp;delay)</p>
<p>下面的adder_t3例子，如果a在15处改变值，输出的值会立即计算并且加入队列，在12ns之后赋值到输出。在输出值被加入队列之后，
还没到达赋值时间之前，always模块会准备好下一次的触发。这就意味着所有的输入时间都会被加入到输出的队列，会在12ns之后生效。&nbsp;这种编码方式描述的是组合逻辑的传输延时。</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t3</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span> <span class="c1">//RHS Nonblocking Assignment</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>

  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span>
    <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">&lt;=</span> <span class="p">#</span><span class="mh">12</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
<p>下图是adder_t3对应的时序波形</p>
<div class="figure">
<img alt="Waveforms for adder_t3.v Example" src="images/tb_adder_t3.png" />
<p class="caption">adder_t3时序波形</p>
</div>
<p><strong>推荐的应用:</strong>&nbsp;用这种代码描述延时线的行为逻辑</p>
<p><strong>建模的准则:</strong> 只把nonblocking assignments的RHS用于传输输出传播行为。这样的编码可以准确的描述出模型的延时线和组合逻辑的纯传输延时，&nbsp;但是这种方式也会倒是仿真的速度变慢，</p>
<p><strong>Test bench准则:</strong> 这种方式经常用于test&nbsp;bench在激励信号需要在时钟沿之后经过延时按计划输出的场景，同时也不会阻塞接下来的时序模块。</p>
</div>
<div class="section" id="multiple-rhs-nonblocking-delays">
<h3>3.3. Multiple <span class="caps">RHS</span> nonblocking&nbsp;delays</h3>
<p>只有在一种情况下，多个sequential nonblocking assignments的RHS演示才正确，即 <strong>所有输入信号和临时变量都要加入敏感信号列表</strong> ；
其他情况下都是有缺陷的。如下面的代码，adder_t9c和adder_t9d的例子。非阻塞赋值是并行执行的而由于tmp信号也在敏感信号列表里面，&nbsp;所以它的变化也可以触发always模块，计算RHS公式并更新LHS的值。</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t9c</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span> <span class="k">or</span> <span class="n">tmp</span><span class="p">)</span> <span class="k">begin</span>
    <span class="n">tmp</span> <span class="o">&lt;=</span> <span class="p">#</span><span class="mh">12</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
    <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">end</span>
<span class="k">endmodule</span>

<span class="k">module</span> <span class="n">adder_t9d</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="n">co</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span> <span class="k">or</span> <span class="n">tmp</span><span class="p">)</span> <span class="k">begin</span>
    <span class="n">tmp</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
    <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">&lt;=</span> <span class="p">#</span><span class="mh">12</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
<p><strong>建模的准则:</strong> 通常来说，不要在非阻塞组合逻辑的RHS侧放delay。这种编码方式容易引起误解，而且仿真效率不高。&nbsp;时序逻辑经常用这种方法来表示clock-to-output行为。</p>
<p><strong>Test bench准则:</strong> 在有些多时钟设计的验证套件会使用这种多个非阻塞模式RHS延时；但是这种编码方式容易引起误解，&nbsp;所以通常来说不推荐在testbench用这种方式。</p>
</div>
</div>
<div class="section" id="continuous-assignment-delay-models">
<h2>4. Continuous assignment delay&nbsp;models</h2>
<p>通过continuous&nbsp;assignments增加延时能精确的给组合逻辑建模，是一种推荐的编码方式。</p>
<div class="highlight"><pre><span></span><span class="k">assign</span> <span class="n">y</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>    <span class="c1">// Continuous assignment - no delay</span>

<span class="k">assign</span> <span class="p">#</span><span class="mh">5</span> <span class="n">y</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span> <span class="c1">// Continuous assignment - LHS delay</span>

<span class="k">assign</span> <span class="n">y</span> <span class="o">=</span> <span class="p">#</span><span class="mh">5</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span> <span class="c1">// Illegal continuous assignment - RHS delay</span>

<span class="k">assign</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>   <span class="c1">// Illegal continuous nonblocking assignment</span>
</pre></div>
<p>下面代码adder_t4例子，输出会在最后一个输入变化之后的12ns内不会变。任何间隔不超过12ns的变化会被加入到队列(输出值会和相应的事件对应)，将会产生新的输出事件。
下图的时序对应的是adder_t4，一开始输入a在15ns的时候有变化，这样会在队列增加一个27ns之后的输出变化事件。但是输入b的一个变化以及输入a的2个后来的变化，
分别在时间17，19，21，从而带来4个输出计划。之后最后一个输出计划实际会完成，输出变化在33ns。
Continuous assignments并不会把输出放到队列，只是追踪到下一个输出变化。从而，Continuous assignments在组合逻辑建模了inertial&nbsp;delays。</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t4</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>

  <span class="k">assign</span> <span class="p">#</span><span class="mh">12</span> <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
<div class="figure">
<img alt="Waveforms for adder_t4.v Example" src="images/tb_adder_t4.png" />
<p class="caption">adder_t4时序波形</p>
</div>
<div class="section" id="multiple-continuous-assignments">
<h3>4.1. Multiple continuous&nbsp;assignments</h3>
<p>类似的可以用continuous assignments增加delay的方法，它的输出通常是来驱动其他的continuous assignments，
如下面的代码所示，它可以精确的对inertial&nbsp;delays建模。</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t10a</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">wire</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>

  <span class="k">assign</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
  <span class="k">assign</span> <span class="p">#</span><span class="mh">12</span> <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="k">endmodule</span>

<span class="k">module</span> <span class="n">adder_t10b</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">wire</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>

  <span class="k">assign</span> <span class="p">#</span><span class="mh">12</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
  <span class="k">assign</span> <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
</div>
<div class="section" id="mixed-no-delay-always-blocks-and-continuous-assignments">
<h3>4.2. Mixed no-delay always blocks and continuous&nbsp;assignments</h3>
<p>在always模块里面的逻辑没有delay，然后把always模块输出的中间值传递给带有delay的continuous assignment，
如下面的代码所示，它也能精确的对组合逻辑的inertial&nbsp;delays建模。</p>
<p>在adder_t5的例子当中，tmp变量会随着任何输入变量变化而更新。continuous assignment outputs在tmp变化之后的
12ns更新。任何always模块输入变化都会导致tmp变化，这都会在。continuous assignment outputs增加计划。
如果tmp保持12ns不变化，那么continuous assignment也不会变化。这种代码可以给inertial&nbsp;delays建模</p>
<div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">adder_t5</span> <span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
  <span class="k">output</span> <span class="n">co</span><span class="p">;</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">sum</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">input</span> <span class="n">ci</span><span class="p">;</span>
  <span class="kt">reg</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>

  <span class="k">always</span> <span class="p">@(</span><span class="n">a</span> <span class="k">or</span> <span class="n">b</span> <span class="k">or</span> <span class="n">ci</span><span class="p">)</span> <span class="k">begin</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">ci</span><span class="p">;</span>
  <span class="k">end</span>
  <span class="k">assign</span> <span class="p">#</span><span class="mh">12</span> <span class="p">{</span><span class="n">co</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
<p><strong>建模的准则:</strong> 用continuous assignments带有delay建模，这种方法可以精确的给组合逻辑inertial&nbsp;delays建模</p>
<p><strong>建模的准则:</strong> 使用always模块不带有delay来建模，可以方便的应用verilog这写行为描述语法如&#8221;case-casez-casex&#8221;, &#8220;if-else&#8221;, 等等。
然后输出到带有delay的continuous assignments， 可以精确的给组合逻辑inertial&nbsp;delays建模</p>
<p><strong>Test bench准则:</strong> continuous&nbsp;assignments可以在teshbench的任何地方来驱动激励值到输入口和双向口。</p>
</div>
</div>
<div class="section" id="id1">
<h2>5. 结论</h2>
</div>



             
 
            
            
            







<section>
    <h6 style="display:none;">Comments</h6>
    <p id="comment-message"> </p>

    <div class="accordion" id="accordion2">
        <div class="accordion-group">
            <div class="accordion-heading">
                <a class="accordion-toggle disqus-comment-count comment-count collapsed"
                   data-toggle="collapse"
                   data-parent="#accordion2"
                   href="https://blog.sipi.tech/verilog_note_about_delay.html#comment_thread"
                   id="comment-accordion-toggle">
                    Comments
                </a>
            </div>
            <div id="comment_thread" class="accordion-body collapse">
                <div class="accordion-inner">
                    <div class="comments">



                        <div class="commentbox" id="verilog_note_about_delay"></div>
<script src="https://unpkg.com/commentbox.io/dist/commentBox.min.js"></script>
<script>
    commentBox("5726956779732992-proj", {
        onCommentCount(count) {
            const ele = document.querySelector("#comment-accordion-toggle")
            if (ele && count > 0) {
                ele.innerText = `${count} Comment${count > 1 ? 's' : ''}`
            }
        }
    });
</script>

                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

            <hr/>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="https://blog.sipi.tech/my-fist-post.html" title="Previous: 第一篇gitpages blog">第一篇gitpages blog</a></li>
            </ul>
            </nav>
            </aside>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2021-07-31T16:35:54.943500+08:00">Jul 31, 2021</time>

            <h4>Category</h4>
            <a class="category-link" href="https://blog.sipi.tech/categories.html#verilog-ref">verilog</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://blog.sipi.tech/tags.html#digital-ref">digital
                    <span class="superscript">1</span>
</a></li>
                <li><a href="https://blog.sipi.tech/tags.html#fpga-ref">FPGA
                    <span class="superscript">1</span>
</a></li>
                <li><a href="https://blog.sipi.tech/tags.html#verilog-ref">verilog
                    <span class="superscript">1</span>
</a></li>
            </ul>
<h4>Contact</h4>
<div id="sidebar-social-link">
</div>
            





            





        </section>
</div>
</article>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>

    <div>
        <span class="site-name">SIPI Tech</span> - a blog for everything about tech
    </div>



    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script src="//cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.0.2/js/bootstrap.min.js"></script>
        <script src="https://blog.sipi.tech/theme/js/elegant.prod.9e9d5ce754.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>